From bd2733361b9435bb56ebb75d2dff443da5933405 Mon Sep 17 00:00:00 2001
From: Sven Obser <sven.obser@backes-srt.de>
Date: Wed, 4 Oct 2017 09:19:00 +0200
Subject: [PATCH 06/13] Fixes Issue #4: Mitigate against approve race condition
 * Documentation of functions.

---
 contracts/PLToken.sol       | 21 ++++++++++++--
 contracts/SafeMath.sol      | 39 ++++++++++++++++++++++---
 contracts/StandardToken.sol | 69 +++++++++++++++++++++++++++++++++++++++++++--
 3 files changed, 120 insertions(+), 9 deletions(-)

diff --git a/contracts/PLToken.sol b/contracts/PLToken.sol
index cb26bea..ed5c70d 100644
--- a/contracts/PLToken.sol
+++ b/contracts/PLToken.sol
@@ -2,7 +2,11 @@ pragma solidity ^0.4.17;
 
 import "./StandardToken.sol";
 
-/* Taking ideas from BAT token */
+/**
+ * @title The Pre-Leo Token contract.
+ *
+ * Credit: Taking ideas from BAT token and NET token
+ */
 contract PLToken is StandardToken {
 
     // Token metadata
@@ -93,7 +97,15 @@ contract PLToken is StandardToken {
         _;
     }
 
-    // Constructor
+    /**
+     * @dev Create a new PLToken contract.
+     *
+     * @param _fundingStartBlock The starting block of the fundraiser (has to be in the future).
+     * @param _fundingEndBlock The end block of the fundraiser (has to be after _fundingStartBlock).
+     * @param _exchangeRateChangesBlock The block that changes the exchange rate (has to be between _fundingStartBlock and _fundingEndBlock).
+     * @param _admin1 The first admin account that owns this contract.
+     * @param _admin2 The second admin account that owns this contract.
+     */
     function PLToken(
         uint256 _fundingStartBlock,
         uint256 _fundingEndBlock,
@@ -227,6 +239,7 @@ contract PLToken is StandardToken {
         require(_value <= this.balance);
         // make sure a recipient was defined !
         require (_safe != 0x0);
+
         // send the eth to where admins agree upon
         _safe.transfer(_value);
     }
@@ -239,9 +252,11 @@ contract PLToken is StandardToken {
     minimumReached
     onlyOwner  // Only the admins calling this method exactly the same way can finalize the sale.
     {
-        require(block.number > fundingEndBlock || totalSupply >= TOKEN_CREATION_CAP || totalReceivedEth >= ETH_RECEIVED_CAP); // Only allow to finalize the contract before the ending block if we already reached any of the two caps
+        // Only allow to finalize the contract before the ending block if we already reached any of the two caps
+        require(block.number > fundingEndBlock || totalSupply >= TOKEN_CREATION_CAP || totalReceivedEth >= ETH_RECEIVED_CAP);
         // make sure a recipient was defined !
         require (_safe != 0x0);
+
         // Move the contract to Finalized state
         state = ContractState.Finalized;
         savedState = ContractState.Finalized;
diff --git a/contracts/SafeMath.sol b/contracts/SafeMath.sol
index 3a90cfa..e26dbf3 100644
--- a/contracts/SafeMath.sol
+++ b/contracts/SafeMath.sol
@@ -1,21 +1,52 @@
 pragma solidity ^0.4.17;
 
-/* taking ideas from FirstBlood token */
+/**
+ * @title Safe math operations that throw error on overflow.
+ *
+ * Credit: Taking ideas from FirstBlood token
+ */
 library SafeMath {
 
-    function add(uint256 x, uint256 y) internal returns(uint256) {
+    /** 
+     * @dev Safely add two numbers.
+     *
+     * @param x First operant.
+     * @param y Second operant.
+     * @return The result of x+y.
+     */
+    function add(uint256 x, uint256 y)
+    internal
+    returns(uint256) {
         uint256 z = x + y;
         assert((z >= x) && (z >= y));
         return z;
     }
 
-    function sub(uint256 x, uint256 y) internal returns(uint256) {
+    /** 
+     * @dev Safely substract two numbers.
+     *
+     * @param x First operant.
+     * @param y Second operant.
+     * @return The result of x-y.
+     */
+    function sub(uint256 x, uint256 y)
+    internal
+    returns(uint256) {
         assert(x >= y);
         uint256 z = x - y;
         return z;
     }
 
-    function mul(uint256 x, uint256 y) internal returns(uint256) {
+    /** 
+     * @dev Safely multiply two numbers.
+     *
+     * @param x First operant.
+     * @param y Second operant.
+     * @return The result of x*y.
+     */
+    function mul(uint256 x, uint256 y)
+    internal
+    returns(uint256) {
         uint256 z = x * y;
         assert((x == 0) || (z/x == y));
         return z;
diff --git a/contracts/StandardToken.sol b/contracts/StandardToken.sol
index 000e36a..41dddc1 100644
--- a/contracts/StandardToken.sol
+++ b/contracts/StandardToken.sol
@@ -2,7 +2,13 @@ pragma solidity ^0.4.17;
 
 import "./SafeMath.sol";
 
+/**
+ * @title The abstract ERC-20 Token Standard definition.
+ *
+ * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
+ */
 contract Token {
+    /// @dev Returns the total token supply.
     uint256 public totalSupply;
 
     function balanceOf(address _owner) constant returns (uint256 balance);
@@ -11,11 +17,16 @@ contract Token {
     function approve(address _spender, uint256 _value) returns (bool success);
     function allowance(address _owner, address _spender) constant returns (uint256 remaining);
 
+    /// @dev MUST trigger when tokens are transferred, including zero value transfers.
     event Transfer(address indexed _from, address indexed _to, uint256 _value);
+
+    /// @dev MUST trigger on any successful call to approve(address _spender, uint256 _value).
     event Approval(address indexed _owner, address indexed _spender, uint256 _value);
 }
 
-/*  ERC 20 token */
+/**
+ * @title Default implementation of the ERC-20 Token Standard.
+ */
 contract StandardToken is Token {
 
     mapping (address => uint256) balances;
@@ -26,6 +37,18 @@ contract StandardToken is Token {
         _;
     }
 
+    /**
+     * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. 
+     * @dev The function SHOULD throw if the _from account balance does not have enough tokens to spend.
+     *
+     * @dev A token contract which creates new tokens SHOULD trigger a Transfer event with the _from address set to 0x0 when tokens are created.
+     *
+     * Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.
+     *
+     * @param _to The receiver of the tokens.
+     * @param _value The amount of tokens to send.
+     * @return True on success, false otherwise.
+     */
     function transfer(address _to, uint256 _value)
     returns (bool success)
     {
@@ -39,6 +62,21 @@ contract StandardToken is Token {
         }
     }
 
+    /**
+     * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the Transfer event.
+     *
+     * @dev The transferFrom method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf. 
+     * @dev This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in 
+     * @dev sub-currencies. The function SHOULD throw unless the _from account has deliberately authorized the sender of 
+     * @dev the message via some mechanism.
+     *
+     * Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.
+     *
+     * @param _from The sender of the tokens.
+     * @param _to The receiver of the tokens.
+     * @param _value The amount of tokens to send.
+     * @return True on success, false otherwise.
+     */
     function transferFrom(address _from, address _to, uint256 _value)
     returns (bool success)
     {
@@ -53,10 +91,31 @@ contract StandardToken is Token {
         }
     }
 
+    /**
+     * @dev Returns the account balance of another account with address _owner.
+     *
+     * @param _owner The address of the account to check.
+     * @return The account balance.
+     */
     function balanceOf(address _owner) constant returns (uint256 balance) {
         return balances[_owner];
     }
 
+    /**
+     * @dev Allows _spender to withdraw from your account multiple times, up to the _value amount. 
+     * @dev If this function is called again it overwrites the current allowance with _value.
+     *
+     * @dev NOTE: To prevent attack vectors like the one described in [1] and discussed in [2], clients 
+     * @dev SHOULD make sure to create user interfaces in such a way that they set the allowance first 
+     * @dev to 0 before setting it to another value for the same spender. THOUGH The contract itself 
+     * @dev shouldn't enforce it, to allow backwards compatilibilty with contracts deployed before.
+     * @dev [1] https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/
+     * @dev [2] https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
+     *
+     * @param _spender The address which will spend the funds.
+     * @param _value The amount of tokens to be spent.
+     * @return True on success, false otherwise.
+     */
     function approve(address _spender, uint256 _value)
     onlyPayloadSize(2)
     returns (bool success)
@@ -66,6 +125,13 @@ contract StandardToken is Token {
         return true;
     }
 
+    /**
+     * @dev Returns the amount which _spender is still allowed to withdraw from _owner.
+     *
+     * @param _owner The address of the sender.
+     * @param _spender The address of the receiver.
+     * @return The allowed withdrawal amount.
+     */
     function allowance(address _owner, address _spender)
     constant
     onlyPayloadSize(2)
@@ -74,4 +140,3 @@ contract StandardToken is Token {
         return allowed[_owner][_spender];
     }
 }
-
-- 
2.7.4.windows.1

